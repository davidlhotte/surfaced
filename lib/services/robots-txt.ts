import { prisma } from '@/lib/db/prisma';
import { logger } from '@/lib/monitoring/logger';

// Types
export interface RobotsTxtConfig {
  allowAllBots: boolean;
  allowAiBots: boolean;
  aiBots: string[];
  disallowedPaths: string[];
  crawlDelay: number | null;
  sitemapUrl: string | null;
  customRules: string | null;
}

export interface GenerateRobotsTxtOptions {
  shopDomain: string;
  config: RobotsTxtConfig;
  includeAiSection: boolean;
}

// Default AI bots to allow
export const DEFAULT_AI_BOTS = [
  'ChatGPT-User',
  'GPTBot',
  'ClaudeBot',
  'Claude-Web',
  'PerplexityBot',
  'Google-Extended',
  'Googlebot',
  'Bingbot',
  'cohere-ai',
  'anthropic-ai',
];

// Common paths to disallow
export const SUGGESTED_DISALLOW_PATHS = [
  '/cart',
  '/checkout',
  '/account',
  '/admin',
  '/orders',
  '/carts',
  '/search',
  '/*?*variant=',
  '/*?*sort_by=',
  '/*?*page=',
];

/**
 * Generate robots.txt content
 */
export function generateRobotsTxt(options: GenerateRobotsTxtOptions): string {
  const { shopDomain, config, includeAiSection } = options;
  const lines: string[] = [];

  // Header comment
  lines.push('# robots.txt for ' + shopDomain);
  lines.push('# Generated by Surfaced - AI Visibility for Shopify');
  lines.push('# https://surfaced.vercel.app');
  lines.push('');

  // General user-agent rules
  lines.push('User-agent: *');

  if (config.allowAllBots) {
    lines.push('Allow: /');
  }

  // Disallowed paths
  for (const path of config.disallowedPaths) {
    lines.push(`Disallow: ${path}`);
  }

  // Crawl delay if specified
  if (config.crawlDelay && config.crawlDelay > 0) {
    lines.push(`Crawl-delay: ${config.crawlDelay}`);
  }

  lines.push('');

  // AI-specific section
  if (includeAiSection && config.allowAiBots && config.aiBots.length > 0) {
    lines.push('# AI Crawlers - Optimized for AI visibility');

    for (const bot of config.aiBots) {
      lines.push('');
      lines.push(`User-agent: ${bot}`);
      lines.push('Allow: /');
      lines.push('Allow: /products/');
      lines.push('Allow: /collections/');
      lines.push('Allow: /pages/');

      // Still disallow checkout/cart for AI bots
      lines.push('Disallow: /cart');
      lines.push('Disallow: /checkout');
      lines.push('Disallow: /account');
    }

    lines.push('');
  }

  // Custom rules
  if (config.customRules) {
    lines.push('# Custom Rules');
    lines.push(config.customRules);
    lines.push('');
  }

  // Sitemap
  if (config.sitemapUrl) {
    lines.push(`Sitemap: ${config.sitemapUrl}`);
  } else {
    lines.push(`Sitemap: https://${shopDomain}/sitemap.xml`);
  }

  lines.push('');
  lines.push('# llms.txt - AI-optimized content guide');
  lines.push(`# https://${shopDomain}/.well-known/llms.txt`);
  lines.push('');
  lines.push(`# Last updated: ${new Date().toISOString().split('T')[0]}`);

  return lines.join('\n');
}

/**
 * Get default robots.txt config
 */
export function getDefaultRobotsTxtConfig(): RobotsTxtConfig {
  return {
    allowAllBots: true,
    allowAiBots: true,
    aiBots: DEFAULT_AI_BOTS,
    disallowedPaths: SUGGESTED_DISALLOW_PATHS,
    crawlDelay: null,
    sitemapUrl: null,
    customRules: null,
  };
}

/**
 * Analyze existing robots.txt for AI-friendliness
 */
export function analyzeRobotsTxt(content: string): {
  isAiFriendly: boolean;
  issues: string[];
  suggestions: string[];
  blockedAiBots: string[];
  score: number;
} {
  const issues: string[] = [];
  const suggestions: string[] = [];
  const blockedAiBots: string[] = [];
  let score = 100;

  const lines = content.split('\n').map(l => l.trim().toLowerCase());

  // Check for blocked AI bots
  const aiBotsLower = DEFAULT_AI_BOTS.map(b => b.toLowerCase());

  let currentUserAgent = '';
  for (const line of lines) {
    if (line.startsWith('user-agent:')) {
      currentUserAgent = line.replace('user-agent:', '').trim();
    }

    if (line.startsWith('disallow: /') && line === 'disallow: /') {
      // Check if this blocks everything for AI bots
      for (const aiBot of aiBotsLower) {
        if (currentUserAgent === '*' || currentUserAgent === aiBot) {
          if (!blockedAiBots.includes(aiBot)) {
            blockedAiBots.push(aiBot);
          }
        }
      }
    }
  }

  // Check for specific AI bot blocks
  for (const aiBot of DEFAULT_AI_BOTS) {
    const botLower = aiBot.toLowerCase();
    const hasUserAgent = lines.some(l => l.includes(`user-agent: ${botLower}`));
    const hasDisallow = lines.some((l, i) => {
      if (l.includes(`user-agent: ${botLower}`)) {
        // Check next lines for disallow
        for (let j = i + 1; j < lines.length && !lines[j].startsWith('user-agent:'); j++) {
          if (lines[j] === 'disallow: /') return true;
        }
      }
      return false;
    });

    if (hasUserAgent && hasDisallow) {
      blockedAiBots.push(aiBot);
    }
  }

  // Score calculation
  if (blockedAiBots.length > 0) {
    score -= blockedAiBots.length * 15;
    issues.push(`${blockedAiBots.length} AI bot(s) are blocked: ${blockedAiBots.join(', ')}`);
    suggestions.push('Allow AI crawlers like GPTBot, ClaudeBot, and PerplexityBot to improve AI visibility');
  }

  // Check for sitemap
  const hasSitemap = lines.some(l => l.startsWith('sitemap:'));
  if (!hasSitemap) {
    score -= 10;
    issues.push('No sitemap specified');
    suggestions.push('Add a sitemap directive to help crawlers discover your content');
  }

  // Check for llms.txt mention
  const hasLlmsTxt = content.toLowerCase().includes('llms.txt');
  if (!hasLlmsTxt) {
    suggestions.push('Consider adding a reference to your llms.txt file for AI crawlers');
  }

  // Check for overly restrictive rules
  const hasWildcardDisallow = lines.some(l =>
    l.startsWith('disallow:') && (l.includes('/*') || l === 'disallow: /')
  );
  if (hasWildcardDisallow && !lines.some(l => l.includes('user-agent:') && l !== 'user-agent: *')) {
    score -= 20;
    issues.push('Overly restrictive rules may block important content');
  }

  score = Math.max(0, Math.min(100, score));
  const isAiFriendly = score >= 70 && blockedAiBots.length === 0;

  return {
    isAiFriendly,
    issues,
    suggestions,
    blockedAiBots,
    score,
  };
}

/**
 * Store robots.txt config in database (using settings or a JSON field)
 */
export async function saveRobotsTxtConfig(
  shopDomain: string,
  config: RobotsTxtConfig
): Promise<void> {
  const shop = await prisma.shop.findUnique({
    where: { shopDomain },
    select: { id: true },
  });

  if (!shop) {
    throw new Error('Shop not found');
  }

  // Store in settings as JSON
  await prisma.settings.upsert({
    where: { shopId: shop.id },
    update: {
      // We'll add robotsTxtConfig to the settings schema later
      // For now, store it in auditLog as a workaround
      updatedAt: new Date(),
    },
    create: {
      shopId: shop.id,
    },
  });

  // Log the change
  await prisma.auditLog.create({
    data: {
      shopId: shop.id,
      action: 'robots_txt_updated',
      details: {
        allowAllBots: config.allowAllBots,
        allowAiBots: config.allowAiBots,
        crawlDelay: config.crawlDelay,
        sitemapUrl: config.sitemapUrl,
      },
    },
  });

  logger.info({ shopDomain }, 'Robots.txt config saved');
}

/**
 * Get current robots.txt from shop
 */
export async function fetchCurrentRobotsTxt(shopDomain: string): Promise<string | null> {
  try {
    // Remove .myshopify.com if present to get the actual storefront domain
    const domain = shopDomain.includes('.myshopify.com') ? shopDomain : `${shopDomain}.myshopify.com`;

    const response = await fetch(`https://${domain}/robots.txt`, {
      headers: {
        'User-Agent': 'Surfaced/1.0 (AI Visibility Analyzer)',
      },
    });

    if (!response.ok) {
      return null;
    }

    return await response.text();
  } catch (error) {
    logger.error({ error, shopDomain }, 'Failed to fetch robots.txt');
    return null;
  }
}
